import torch
import torch.nn as nn
import pandas as pd
from pathlib import Path
import logging

log = logging.getLogger(__name__)

class FeatureNormalizer(nn.Module):
    """
    Handles loading, storing, and applying normalization stats for Yemong models.
    Stats are registered as buffers so they are saved with the model state_dict.
    """
    def __init__(self, stats_csv: str | Path | None = None):
        super().__init__()
        self.stats = {}
        if stats_csv:
            self.load_stats(stats_csv)

    def load_stats(self, stats_csv: str | Path):
        """Loads stats from a CSV file generated by tools/dataset_stats.py"""
        df = pd.read_csv(stats_csv, sep='|', index_col=0)
        for feature, row in df.iterrows():
            # Register each stat as a buffer
            for stat in ['Mean', 'Std', 'RMS', 'Min', 'Max']:
                if stat in row:
                    name = f"{feature}_{stat.lower()}".replace('.', '_')
                    self.register_buffer(name, torch.tensor(float(row[stat]), dtype=torch.float32))
                    self.stats[f"{feature}_{stat.lower()}"] = name

    def get_stat(self, feature: str, stat: str) -> torch.Tensor:
        """Retrieves a specific stat for a feature."""
        name = f"{feature}_{stat.lower()}".replace('.', '_')
        if hasattr(self, name):
            return getattr(self, name)
        raise AttributeError(f"Stat '{stat}' for feature '{feature}' not found in normalizer.")

    def normalize(self, x: torch.Tensor, feature: str, strategy: str) -> torch.Tensor:
        """Applies a normalization strategy to a feature tensor."""
        if strategy == "Identity":
            return x
        elif strategy == "Min-Max":
            min_val = self.get_stat(feature, "min")
            max_val = self.get_stat(feature, "max")
            return (x - min_val) / (max_val - min_val + 1e-6)
        elif strategy == "Scale (RMS)":
            rms_val = self.get_stat(feature, "rms")
            return x / (rms_val + 1e-6)
        elif strategy == "Z-Score":
            mean_val = self.get_stat(feature, "mean")
            std_val = self.get_stat(feature, "std")
            return (x - mean_val) / (std_val + 1e-6)
        else:
            raise ValueError(f"Unknown normalization strategy: {strategy}")

    @staticmethod
    def transform(x: torch.Tensor, transformation: str) -> torch.Tensor:
        """Applies a functional transformation to a tensor."""
        if transformation == "Log":
            return torch.log(x + 1.0)
        elif transformation == "Symlog":
            return torch.sign(x) * torch.log(torch.abs(x) + 1.0)
        elif transformation == "Identity":
            return x
        else:
            raise ValueError(f"Unknown transformation: {transformation}")
